'use server'

import { prisma } from "@/lib/prisma"
import { getAuthSession } from "@/lib/auth"
import { revalidatePath } from "next/cache"
import { authenticator } from "otplib"

export async function markManualAttendance(sessionId: string, code: string, lat?: number, lng?: number) {
    const session = await getAuthSession()
    if (!session) return { success: false, message: "Unauthorized" }

    try {
        const attSession = await prisma.attendanceSession.findUnique({
            where: { id: sessionId }
        })

        if (!attSession) return { success: false, message: "Session not found" }
        if (!attSession.isActive) return { success: false, message: "Session has ended" }

        // Verify TOTP
        // Note: authenticator expects secret and token.
        // We stored totpSecret in DB.
        // The code entered by student must match valid codes generated by that secret.
        if (!attSession.totpSecret) return { success: false, message: "TOTP verify failed: Secret missing" }
        const isValid = authenticator.verify({ token: code, secret: attSession.totpSecret })

        if (!isValid) return { success: false, message: "Invalid code" }

        // Duplication Check
        const existingRecord = await prisma.attendanceRecord.findUnique({
            where: {
                sessionId_userId: {
                    sessionId,
                    userId: session.user.id
                }
            }
        })
        if (existingRecord) return { success: false, message: "Attendance already marked." }

        // Geo Check (Reuse logic or keep optional for manual?)
        // Let's enforce it if session requires it.
        if (attSession.locationLat && attSession.locationLng && attSession.locationRadius) {
            if (!lat || !lng) return { success: false, message: "Location permission required for this session." }

            const distance = getDistanceFromLatLonInKm(lat, lng, Number(attSession.locationLat), Number(attSession.locationLng)) * 1000 // meters
            if (distance > Number(attSession.locationRadius)) {
                return { success: false, message: `You are too far from the session location (${Math.round(distance)}m away).` }
            }
        }

        await prisma.attendanceRecord.create({
            data: {
                sessionId,
                userId: session.user.id,
                // coeId is derived from session
                method: "MANUAL", // Assuming method is the field name for SessionType in record
                locationLat: lat,
                locationLng: lng,
                verified: true
            }
        })

        revalidatePath("/student/dashboard")
        return { success: true }

    } catch (e) {
        return { success: false, message: "Failed to mark attendance" }
    }
}

// Distance Helper (Haversine)
function getDistanceFromLatLonInKm(lat1: number, lon1: number, lat2: number, lon2: number) {
    var R = 6371; // Radius of the earth in km
    var dLat = deg2rad(lat2 - lat1);
    var dLon = deg2rad(lon2 - lon1);
    var a =
        Math.sin(dLat / 2) * Math.sin(dLat / 2) +
        Math.cos(deg2rad(lat1)) * Math.cos(deg2rad(lat2)) *
        Math.sin(dLon / 2) * Math.sin(dLon / 2)
        ;
    var c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
    var d = R * c; // Distance in km
    return d;
}

function deg2rad(deg: number) {
    return deg * (Math.PI / 180)
}
